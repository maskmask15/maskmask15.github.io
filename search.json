[{"title":"AI Sys学习记录 --- AI 计算体系概述","path":"/2025/08/22/AI Sys学习记录01/","content":"前言最近在学习zomi酱大佬的AI Sys，记录一下作为菜鸡的学习历程，也分享一下自己浅薄的认识(狗头保命)。不会严格按照大佬的章节安排走，也不是一节一个记录，可能看过去一部分才回头来写之前东西。个人见解，个人认识，有不妥或错误之处可以指出，欢迎交流学习。 1. 并行计算并行计算是把一个计算任务拆成若干可同时执行的子任务，在多个处理单元（多核CPU、GPU、加速器、集群节点等）上同时运行，从而缩短总耗时、提高吞吐、或者节能。和”并发”不同：并发是同一时间段内交替推进多任务；并行是同一时刻真正同时做多件事（需要多个硬件执行单元）。 并行性的来源，如何拆分任务？数据并行（Data Parallelism）任务并行（TaskFunctional Parallelism）向量化（SIMDSIMT）子任务越小并行度越高，但同步调度成本也更高，要权衡速度与能耗。 并行模式生产-消费模式一个或多个生产者负责不断生成数据任务。一个或多个消费者负责不断取数据处理任务。二者通过共享的缓冲区交互（队列），生产者放入，消费者取出。生产和消费可并行，互不等待。例如，前段时间刚做过的RK3588开发板上部署模型（后续会更新），为加速计算，开线程方式就是使用了这种模式。实际应用中从摄像头采集帧，丢到队列中，同时充分利用NPU三个核心，（生产线程）。然后从队列中取帧，前处理，丢到NPU进行推理，后处理（消费线程）。可极大提升 NPU 利用率，提高帧率。由单线程的5FPS左右提高到18~19FPS。Fork-JoinFork：将任务拆分为多个可并行的子任务。Join：等待子任务完成之后，合并结果，继续执行后续任务。例如，模型分布式训练中的数据并行训练，多块 GPU 同时计算梯度，最后All-Reduce 汇总。流水线并行将任务分成若干阶段，向流水线一样流动执行。例如，在复旦微电子100TAI上做过的模型部署工作（后续会更新）。将部署任务划分成前处理，推理，后处理，三个阶段，开线程方式使用这种方式，同时使用多个缓存区域缓存数据。这样做理论上极限速度就是推理速度，可充分利用27T的算力。但是芯片上只有一个ai core，不能像RK3588那样利用三个NPU核心分别处理三帧图像。 2. Roofline模型3. 数据位宽","tags":["AI Sys","学习记录","硬件体系结构","编译与计算架构","推理系统&引擎","AI 框架"],"categories":["AI Sys"]},{"title":"leetcode刷题记录-20250809，day18，二叉树","path":"/2025/08/22/leetcode刷题记录-20250809，day18，二叉树/","content":"LeetCode 刷题记录 - 2025-08-09今天刷题总结如下： 题目 1: LeetCode 530.二叉搜索树的最小绝对差 题目描述：给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。难度: Easy 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。一开始的时候也没有考虑到中序遍历二叉搜索树是递增序列，，，后来也是看了思路之后才发现中序遍历是递增的，清楚这一点之后这道题就不难了。还有就是要维护一个全局的前值，这样就可以比较当前元素与前一个元素的差值了。💡 OS： 注意中序遍历二叉搜索树就是一个递增的遍历，最小绝对差出现在相邻元素之间，即可只比较相邻元素直接的差值。维护全局的前值。 代码如下class Solution public:int result = INT_MAX;int prev_val = -1; // 中序遍历二叉搜索树就是一个递增去遍历 // 最小绝对差出现在相邻元素之间，即可只比较相邻元素直接的差值 void inorder(TreeNode* root) if (!root) return; inorder(root-left); if (prev_val!=-1) result = min(result, root-val-prev_val); prev_val = root-val; inorder(root-right); int getMinimumDifference(TreeNode* root) inorder(root); return result; ; 题目 2: LeetCode 501.二叉搜索树中的众数 题目描述：给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义：结点左子树中所含节点的值 小于等于 当前节点的值结点右子树中所含节点的值 大于等于 当前节点的值左子树和右子树都是二叉搜索树难度: Easy 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。这个题是去找二叉搜索树的众数，对于二叉搜索树的题，包先想到中序遍历，然后发现这个题用不用都行。。。其次我又想到之前做的哈希表的题，用哈希表去记录这种出现次数很方便，所以我维护了一个全局的哈希表去记录每个数出现的次数，最后遍历一下把数放进vector中就好了。 代码如下class Solution public:unordered_mapint, int record; static bool cmp_value(const pairint, int left,const pairint,int right) return left.second right.second; void travelTree(TreeNode* root) if (!root) return; travelTree(root-left); record[root-val]++; travelTree(root-right); vectorint findMode(TreeNode* root) vectorint result; if (!root-left !root-right) return root-val; travelTree(root); auto max_i = max_element(record.begin(), record.end(), cmp_value); for (auto i : record) if (i.second == max_i-second) result.push_back(i.first); return result; ; 题目 3: LeetCode 236. 二叉树的最近公共祖先 题目描述：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科 中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”难度: Medium 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。这道题要找给定两个节点的最近的公共祖先，首先考虑要遍历二叉树找到该节点，把路径保存下来。这样做要遍历两边二叉树，然后两个for循环找公共节点，然后返回深度最大的节点。写代码时遇到的问题就是我一开始没有给停止信号，定义的void函数，递归条件哪里就有问题，当找到节点就返回。然后提交就发现只能通过一个或者直接溢出了。。后来定义bool函数，找到节点返回true就不递归了，否则返回false。这样做就可以了。 💡 OS： 这里要注意回溯，当左右子树都没找到节点时pop一个节点。 代码如下class Solution public: bool travelTree(TreeNode* root, TreeNode* node, vectorTreeNode* record) if (!root) return false; record.push_back(root); if (root == node) return true; if (travelTree(root-left, node, record)) return true; if (travelTree(root-right, node, record)) return true; record.pop_back(); return false; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) vectorTreeNode* an_p; vectorTreeNode* an_q; travelTree(root, p, an_p); travelTree(root, q, an_q); vectorTreeNode* result; for (int i = 0; i an_p.size(); i++) for (int j = 0; j an_q.size(); j++) if (an_p[i] == an_q[j]) result.insert(result.begin(), an_p[i]); return result[0]; ;","tags":["刷题","数据结构","算法","二叉树"],"categories":["LeetCode"]},{"title":"leetcode刷题记录-20250808，day17，二叉树","path":"/2025/08/21/leetcode刷题记录-20250808，day17，二叉树/","content":"LeetCode 刷题记录 - 2025-08-08今天刷题总结如下： 题目 1: LeetCode 654.最大二叉树题目描述：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:创建一个根节点，其值为 nums 中的最大值。递归地在最大值 左边 的 子数组前缀上 构建左子树。递归地在最大值 右边 的 子数组后缀上 构建右子树。返回 nums 构建的 最大二叉树 。难度: Medium 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。这道题是要通过给定的数组创建最大二叉树，根节点是当前子数组的最大值，左子数组是构造左子树，右子数组构造右子树。单层递归就是要去找到最大值以及最大值的索引，将最大值赋值给当前根节点，通过索引划分左右子数组。当数组为空的时候递归结束。💡 OS： 要注意划分左右子数组时的切分点，因为切分点已经被赋给当前的根节点，所以左右子数组都不包括切分点。 代码如下class Solution public: TreeNode* constructMaximumBinaryTree(vectorint nums) if (nums.empty()) return nullptr; int index = 0; int max = nums[0]; for (int i = 0; i nums.size(); i++) if (max nums[i]) max = nums[i]; index = i; TreeNode* root = new TreeNode(max); if (nums.size() == 1) return root; // 切分左右子树时注意切分点，不包括切分点！！ vectorint numsLeft(nums.begin(), nums.begin()+index); vectorint numsRight(nums.begin()+index+1, nums.end()); root-left = constructMaximumBinaryTree(numsLeft); root-right = constructMaximumBinaryTree(numsRight); return root; ; 题目 2: LeetCode 617.合并二叉树 题目描述：给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。难度: Easy 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。这个题合并二叉树，不难，就把两个数都遍历一遍就行了，考虑全合并时的情况就好了。 代码如下class Solution public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) if (!root1 !root2) return nullptr; if (!root1 root2) TreeNode* root = new TreeNode(root2-val); root-left = mergeTrees(nullptr, root2-left); root-right = mergeTrees(nullptr, root2-right); return root; if (root1 !root2) TreeNode* root = new TreeNode(root1-val); root-left = mergeTrees(root1-left, nullptr); root-right = mergeTrees(root1-right, nullptr); return root; TreeNode* root = new TreeNode(root1-val + root2-val); root-left = mergeTrees(root1-left, root2-left); root-right = mergeTrees(root1-right, root2-right); return root; ; 题目 3: LeetCode 700.二叉搜索树中的搜索 题目描述：给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。难度: Easy 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。给定二叉搜索树和整数值，二叉搜索树就是根节点的值大于左孩子，小于右孩子，就是判断一下当前节点的值和给定的整数的大小关系。💡 OS： 代码如下class Solution public: TreeNode* searchBST(TreeNode* root, int val) TreeNode* next; if (!root) return nullptr; else if (root-val != val) next = (root-val val) ? root-left : root-right; else if (root-val == val) return root; return searchBST(next, val); ; 题目 4: LeetCode 98.验证二叉搜索树 题目描述：给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下：节点的左子树只包含 严格小于 当前节点的数。节点的右子树只包含 严格大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。难度: Medium 思路二叉树题目一般考虑递归。对于递归，1、确定递归函数的参数和返回值；2、确定终止条件；3、确定单层递归的逻辑。判断给定的二叉树是否是有效的二叉搜索树，题目也给出了有效二叉搜索树定义。一开始没有考虑到OS中的情况，只判断了当前节点与当前节点的左右孩子。所以正确解法是：维护一个最大值最小值，遍历左子树时更新最大值，遍历右子树时更新最小值。节点值不满足 [min_val, max_val] 这个区间时返回false。💡 OS： 要注意左子树的所有节点的值都要严格小于根节点的值，右子树所有节点的值都要严格大于根节点的值！ 代码如下class Solution public: // 让左右子树各个结点的值都在一个范围内！！！ bool travelTree(TreeNode* root, long min_val, long max_val) if (!root) return true; if (root-val = min_val || root-val = max_val) return false; return travelTree(root-left, min_val, root-val) travelTree(root-right, root-val, max_val); bool isValidBST(TreeNode* root) return travelTree(root, LONG_MIN, LONG_MAX); ;","tags":["刷题","数据结构","算法","二叉树"],"categories":["LeetCode"]},{"title":"RK3588 平台部署 YOLO11-Seg","path":"/2025/08/21/RK3588-平台-YOLO11-Seg-部署与优化/","content":"本文记录了在 RK3588 开发板上部署 YOLO11-Seg 的流程，涵盖环境准备、模型转换与推理测试。 1. 环境准备此处列出的是我使用的相关环境，由于使用pytorch较多，所以训练框架默认pytorch。PC端需安装pytorch相关环境，环境安装及模型训练不过多说明（因为不是训练调参分享，哈哈）。官方文档环境要求如下，但是经过我实际使用发现，Ubuntu 16.04.7 LT + Python 3.10也可用。 PC端Ubuntu 16.04.7 LTPython 3.10.18Pytorch 2.2.0CUDA 12.1cmake 3.18.4aarch64-linux-gnu-gcc 6.2.1aarch64-linux-gnu-g++ 6.2.1RKNN-Toolkit2 v2.3.2 # 安装 RKNN-Toolkit2# 请根据不同的 python 版本及处理器架构，选择不同的 wheel 安装包文件：# 其中 x.x.x 是 RKNN-Toolkit2 版本号，cpxx 是 python 版本号pip install packages/x86_64/rknn_toolkit2-x.x.x-cpxx-cpxx-manylinux_2_17_x86_64.manylinux2014_x86_64.whl 板端# 查询 NPU 驱动版本dmesg | grep -i rknpu 或cat /sys/kernel/debug/rknpu/version 或cat /sys/kernel/debug/rknpu/driver_version 或cat /proc/debug/rknpu/driver_version# 显示 RKNPU driver: vX.X.X# 查询rknn_server版本strings /usr/bin/rknn_server | grep -i rknn_server version# 显示 rknn_server version: X.X.X# 查询librknnrt.so库版本strings /usr/lib/librknnrt.so | grep -i librknnrt version# 显示 librknnrt version: X.X.X 2. 模型转换模型转换分为两步，第一步由训练好的.pt转为.onnx，第二步从.onnx转为RKNPU可用的.rknn格式模型。模型训练框架使用的是YOLO11-Seg官方的版本(Ultralytics)。转换onnx同样有两种方式，第一种是利用Ultralytics提供直接导出.rknn格式的接口，我暂时未使用，大家可以试一下。第二种方式用rockchip提供的YOLO11代码导出(https://github.com/airockchip/ultralytics_yolo11). # 调整 ./ultralytics/cfg/default.yaml 中 model 文件路径，默认为 yolo11n.pt，若自己训练模型，请调接至对应的路径。python ./ultralytics/engine/exporter.py# 执行完毕后，会生成 ONNX 模型. 假如原始模型为 yolo11n.pt，则生成 yolo11n.onnx 模型。 rockchip修改了输出信息。官方版本导出onnx后只有一个输出[1, 84, 8400], 下图是通过rockchip提供代码导出。 转换onnx完成后，可以测试推理效果，一般情况下与pt结果一致。测试无误后利用rknn的api进行rknn模型转换，这里仅贴部分代码，完整代码会在仿真测试后给出。 # 创建 RKNN 对象rknn = RKNN(verbose=False)# 参数设置，这里做了归一化，在后续C代码中就不需要了，目标平台根据自己需求选择。rknn.config(mean_values=[[0, 0, 0]], std_values=[[255, 255, 255]], target_platform=platform)# 加载 onnx 模型ret = rknn.load_onnx(model=model_path)# 构建，这里可选是否对模型做量化，RK3588上只支持i8以及fp16格式。ret = rknn.build(do_quantization=do_quant, dataset=DATASET_PATH)# 开导ret = rknn.export_rknn(output_path) 3. 仿真测试仿真正确是上版正确的前提！！话不多说，直接上代码。 # 在仿真时这个的target要设置为None。ret = rknn.init_runtime(target=None, device_id=None, perf_debug=False)# 这里的 img 要经过前处理，比如补尺寸（letterbox），注意通过cv2.imread读进来的图片默认是BGR格式，如果你的模型接收的格式是RGB需要做转换outputs = rknn.inference(inputs=[img]) 完整代码！！ 点击展开代码 import osimport sysimport numpy as npfrom rknn.api import RKNNrealpath = os.path.abspath(__file__)_sep = os.path.seprealpath = realpath.split(_sep)sys.path.append(os.path.join(realpath[0]+_sep, *realpath[1:realpath.index(rknn_model_zoo-main)+1]))from py_utils.coco_utils import COCO_test_helperimport cv2from yolo11_seg import merge_seg, post_processDATASET_PATH = xxxDEFAULT_RKNN_PATH = xxxDEFAULT_QUANT = Trueimg_path = xxxdef parse_arg(): if len(sys.argv) 3: print(Usage: python3 onnx_model_path [platform] [dtype(optional)] [output_rknn_path(optional)].format(sys.argv[0])); print( platform choose from [rk3562, rk3566, rk3568, rk3576, rk3588, rv1126b, rv1109, rv1126, rk1808]) print( dtype choose from [i8, fp] for [rk3562, rk3566, rk3568, rk3576, rk3588, rv1126b]) print( dtype choose from [u8, fp] for [rv1109, rv1126, rk1808]) exit(1) model_path = sys.argv[1] platform = sys.argv[2] do_quant = DEFAULT_QUANT if len(sys.argv) 3: model_type = sys.argv[3] if model_type not in [i8, u8, fp]: print(ERROR: Invalid model type: .format(model_type)) exit(1) elif model_type in [i8, u8]: do_quant = True else: do_quant = False if len(sys.argv) 4: output_path = sys.argv[4] else: output_path = DEFAULT_RKNN_PATH return model_path, platform, do_quant, output_pathif __name__ == __main__: model_path, platform, do_quant, output_path = parse_arg() # 创建 RKNN 对象 rknn = RKNN(verbose=False) # 参数设置，这里做了归一化，在后续C代码中就不需要了，目标平台根据自己需求选择。 print(-- Config model) rknn.config(mean_values=[[0, 0, 0]], std_values=[[255, 255, 255]], target_platform=platform) print(done) # 加载 onnx 模型 print(-- Loading model) ret = rknn.load_onnx(model=model_path) if ret != 0: print(Load model failed!) exit(ret) print(done) # 构建，这里可选是否对模型做量化，RK3588上只支持i8以及fp16格式。 print(-- Building model) ret = rknn.build(do_quantization=do_quant, dataset=DATASET_PATH) if ret != 0: print(Build model failed!) exit(ret) print(done) # 在仿真时这个的target要设置为None。 print(-- Init runtime environment) ret = rknn.init_runtime(target=None, device_id=None, perf_debug=False) if ret != 0: print(Init runtime environment failed!) exit(ret) print(done) # 这里可选仿真精度分析，可以查看每一层结果差异 # # print(-- Accuracy analysis) # Ret = rknn.accuracy_analysis(inputs=[img_path], # target=None) # if ret != 0: # print(Accuracy analysis failed!) # exit(ret) # print(done) # 开导 print(-- Export rknn model) ret = rknn.export_rknn(output_path) if ret != 0: print(Export rknn model failed!) exit(ret) print(done) # 官方提供了接口直接生成C代码，简化了开发流程，可以在此基础上进行二次开发，目前我用这部分代码只测试精度。 # print(-- codegen) # ret = rknn.codegen(output_path=./rknn_app_demo, # inputs=[img_path], overwrite=True) # if ret != 0: # print(Export rknn model failed!) # exit(ret) # print(done) IMG_SIZE = (640, 640) # (width, height) co_helper = COCO_test_helper(enable_letter_box=True) img_src = cv2.imread(img_path) img = co_helper.letter_box(im= img_src.copy(), new_shape=(IMG_SIZE[1], IMG_SIZE[0]), pad_color=(114, 114, 114)) img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) img = np.expand_dims(img, 0); # 这里的 img 要经过前处理，比如补尺寸（letterbox），注意通过cv2.imread读进来的图片默认是BGR格式，如果你的模型接收的格式是RGB需要做转换 print(-- Running model) outputs = rknn.inference(inputs=[img]) print(done) boxes, classes, scores, seg_img = post_process(outputs) if boxes is not None: real_boxs = co_helper.get_real_box(boxes) real_segs = co_helper.get_real_seg(seg_img) img_p = merge_seg(img_src, real_segs, classes) img_output_path = ./xxx if not os.path.exists(img_output_path): os.mkdir(img_output_path) result_path = os.path.join(img_output_path, xxx.png) cv2.imwrite(result_path, img_p) print(saved to .format(result_path)) # Release rknn.release() 4. 编译及上版测试编写C代码，只是想测试的话可以直接使用官方提供的yolov8-seg的demo，因为前后处理是一样的操作，后续我会把我的代码链接放进来（其实是还没整理好，太乱了）。PC端测试、仿真测试以及上版测试结果如下。后续会更新优化部分。","tags":["RK3588","YOLO11","目标检测","实例分割"],"categories":["AI部署"]},{"title":"关于","path":"/about/index.html","content":"友链关于昵称简介 关于本站 本站没有任何推广和打赏链接，如果您觉得哪个作品不错，欢迎去对应的仓库点个赞，或者在对应的文章下面留言互动一下。 开源项目无任何盈利目的，只在工作闲暇时间进行维护，有相关需求请前往对应项目提 Issue 进行反馈，通过私人邮件询问开源项目问题可能得不到答复。"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"朋友文章","path":"/friends/rss/index.html","content":""},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办? 添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与博主有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明 降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！ 如果您没有满足上述条件，即时提交了申请也不会通过哦～ 第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：title: xxxurl: https://xxx.comavatar: screenshot: 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"}]